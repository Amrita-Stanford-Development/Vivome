<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>VivOME Documentation</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      background: #F5F5F3;
      color: #4B4B4B;
      font-family: "Poppins", sans-serif;
      height: 100vh;
      overflow: hidden;
    }
    #bgCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    .container {
      display: flex;
      height: 100%;
      position: relative;
      z-index: 1;
    }
    .left {
      flex: 0.3;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: stretch;
      padding: 2rem 1rem;
      background: transparent;
      border-right: none;
      min-height: 100vh;
      position: relative;
      z-index: 2;
    }

    .nav-container {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      width: 100%;
      z-index: 5;
      position: relative;
    }

    a.back-button {
      position: fixed !important;
      top: 1rem !important;
      left: 1rem !important;
      padding: 0.4rem 0.8rem !important;
      text-decoration: none !important;
      color: #666 !important;
      border-radius: 6px !important;
      transition: all 0.3s ease !important;
      font-weight: 500 !important;
      background: rgba(255, 255, 255, 0.95) !important;
      backdrop-filter: blur(10px) !important;
      border: 1px solid rgba(100, 100, 100, 0.2) !important;
      text-align: center !important;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08) !important;
      display: inline-block !important;
      font-size: 0.8rem !important;
      z-index: 100 !important;
      transform: none !important;
    }

    a.back-button:hover {
      background: rgba(255, 255, 255, 1) !important;
      color: #333 !important;
      transform: translateY(-1px) !important;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.12) !important;
      border-color: rgba(100, 100, 100, 0.4) !important;
    }

    .nav-menu {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
      padding: 0;
    }

    .nav-link {
      padding: 1rem 1.5rem;
      text-decoration: none;
      color: #4B4B4B;
      border-radius: 15px;
      transition: all 0.3s ease;
      font-weight: 500;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(0, 142, 204, 0.15);
      transform: translateZ(8px);
      position: relative;
      text-align: center;
      box-shadow: 
        0 8px 25px rgba(0, 142, 204, 0.08),
        0 4px 15px rgba(0, 0, 0, 0.04);
    }

    .nav-link::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      background: linear-gradient(135deg, 
        rgba(0, 142, 204, 0.15) 0%, 
        rgba(0, 142, 204, 0.08) 50%,
        rgba(0, 142, 204, 0.15) 100%);
      border-radius: 18px;
      z-index: -1;
      filter: blur(8px);
      opacity: 0;
      transition: all 0.3s ease;
    }

    .nav-link:hover, .nav-link.active {
      background: rgba(255, 255, 255, 0.95);
      color: #008ECC;
      transform: translateZ(18px) translateX(8px) scale(1.03);
      box-shadow: 
        0 15px 40px rgba(0, 142, 204, 0.12),
        0 8px 25px rgba(0, 0, 0, 0.06);
    }

    .nav-link:hover::before, .nav-link.active::before {
      opacity: 1;
      transform: scale(1.05);
    }

    .nav-link.active {
      background: #008ECC !important;
      color: white !important;
      border-color: #008ECC !important;
      font-weight: 600 !important;
    }

    .right {
      flex: 1;
      position: relative;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 2rem;
      max-height: 100vh;
    }

    /* Documentation Styles */
    .doc-content {
      max-width: 100%;
    }

    .doc-section {
      display: none;
      animation: sectionSlideIn 0.6s ease-out;
    }

    .doc-section.active {
      display: block;
    }

    @keyframes sectionSlideIn {
      from { 
        opacity: 0; 
        transform: translateY(30px) translateZ(-50px);
      }
      to { 
        opacity: 1; 
        transform: translateY(0) translateZ(0);
      }
    }

    .section-card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 25px;
      padding: 2.5rem;
      margin-bottom: 2rem;
      border: 1px solid rgba(0, 142, 204, 0.2);
      position: relative;
      transition: box-shadow 0.3s ease, border-color 0.3s ease;
      box-shadow: 
        0 20px 40px rgba(0, 142, 204, 0.12),
        0 12px 25px rgba(0, 142, 204, 0.08),
        0 6px 15px rgba(0, 0, 0, 0.06);
    }

    .section-card {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 25px;
      padding: 2.5rem;
      margin-bottom: 2rem;
      border: 1px solid rgba(0, 142, 204, 0.2);
      position: relative;
      transition: box-shadow 0.3s ease, border-color 0.3s ease;
      box-shadow: 
        0 20px 40px rgba(0, 142, 204, 0.12),
        0 12px 25px rgba(0, 142, 204, 0.08),
        0 6px 15px rgba(0, 0, 0, 0.06);
    }

    .section-card:hover {
      box-shadow: 
        0 25px 50px rgba(0, 142, 204, 0.15),
        0 15px 35px rgba(0, 142, 204, 0.10),
        0 8px 20px rgba(0, 0, 0, 0.08);
      border-color: rgba(0, 142, 204, 0.3);
    }

    .section-card h2 {
      color: #008ECC;
      font-size: 2.2rem;
      margin-bottom: 1.5rem;
      font-weight: 700;
      text-align: center;
    }

    .section-card h3 {
      color: #008ECC;
      font-size: 1.4rem;
      margin: 1.5rem 0 1rem 0;
      font-weight: 600;
    }

    .section-card p {
      color: #4B4B4B;
      line-height: 1.7;
      margin-bottom: 1rem;
    }

    .key-points {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1.5rem;
      margin: 2rem 0;
    }

    .point {
      background: rgba(255, 255, 255, 0.9);
      padding: 1.5rem;
      border-radius: 15px;
      border: 1px solid rgba(0, 142, 204, 0.15);
      position: relative;
      transform: translateZ(5px);
      transition: all 0.3s ease;
      box-shadow: 0 8px 25px rgba(0, 142, 204, 0.08);
    }

    .point::before {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      background: linear-gradient(135deg, 
        rgba(0, 142, 204, 0.06) 0%, 
        rgba(0, 142, 204, 0.03) 50%,
        rgba(0, 142, 204, 0.06) 100%);
      border-radius: 18px;
      z-index: -1;
      filter: blur(8px);
      opacity: 0;
      transition: all 0.3s ease;
    }

    .point:hover {
      transform: translateZ(15px) scale(1.02);
      box-shadow: 0 15px 40px rgba(0, 142, 204, 0.06);
    }

    .point:hover::before {
      opacity: 0;
    }

    .point h3 {
      margin-top: 0;
      color: #008ECC;
      font-size: 1.2rem;
    }

    .outcome-box {
      background: rgba(255, 255, 255, 0.9);
      padding: 2rem;
      border-radius: 20px;
      border: 1px solid rgba(0, 142, 204, 0.2);
      margin: 2rem 0;
      position: relative;
      transform: translateZ(8px);
      transition: all 0.3s ease;
      box-shadow: 0 12px 35px rgba(0, 142, 204, 0.12);
    }

    .outcome-box::before {
      content: '';
      position: absolute;
      top: -5px;
      left: -5px;
      right: -5px;
      bottom: -5px;
      background: linear-gradient(135deg, 
        rgba(0, 142, 204, 0.08) 0%, 
        rgba(0, 142, 204, 0.04) 50%,
        rgba(0, 142, 204, 0.08) 100%);
      border-radius: 25px;
      z-index: -1;
      filter: blur(10px);
      opacity: 0.3;
      transition: all 0.3s ease;
    }

    .outcome-box:hover {
      transform: translateZ(18px) scale(1.01);
      box-shadow: 0 20px 50px rgba(0, 142, 204, 0.08);
    }

    .outcome-box:hover::before {
      opacity: 0;
    }

    .outcome-box h3 {
      color: #008ECC;
      margin-top: 0;
    }

    ul {
      color: #4B4B4B;
      line-height: 1.6;
    }

    ul li {
      margin-bottom: 0.5rem;
    }

    strong {
      color: #008ECC;
    }

    em {
      color: #666;
      font-style: italic;
    }

    @media (max-width: 900px) {
      .container {
        flex-direction: column;
        overflow-y: auto;
      }
      .left {
        flex: 0;
        padding: 1rem;
        background: rgba(245, 245, 243, 0.9);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(0, 142, 204, 0.1);
        justify-content: flex-start;
      }
      .nav-container {
        width: 100%;
      }
      a.back-button {
        top: 0.8rem !important;
        left: 0.8rem !important;
        padding: 0.3rem 0.6rem !important;
        font-size: 0.75rem !important;
      }
      .nav-menu {
        flex-direction: row;
        overflow-x: auto;
        gap: 0.5rem;
        padding: 0.5rem 0;
      }
      .nav-link {
        white-space: nowrap;
        padding: 0.8rem 1.2rem;
        font-size: 0.9rem;
        min-width: auto;
        background: rgba(255, 255, 255, 0.9);
        transform: translateZ(5px);
      }
      .nav-link:hover, .nav-link.active {
        transform: translateZ(12px) translateY(-2px) scale(1.02);
      }
      .right {
        flex: 1;
        padding: 1rem;
      }
      .section-card {
        padding: 1.5rem;
      }
      .key-points {
        grid-template-columns: 1fr;
        gap: 1rem;
      }
    }

    @media (max-width: 600px) {
      .left {
        padding: 0.8rem;
      }
      a.back-button {
        top: 0.5rem !important;
        left: 0.5rem !important;
        padding: 0.25rem 0.5rem !important;
        font-size: 0.7rem !important;
      }
      .nav-menu {
        gap: 0.3rem;
      }
      .nav-link {
        padding: 0.6rem 1rem;
        font-size: 0.8rem;
      }
      .right {
        padding: 0.5rem;
      }
      .section-card {
        padding: 1rem;
      }
      .section-card h2 {
        font-size: 1.8rem;
      }
      .point {
        padding: 1rem;
      }
      .outcome-box {
        padding: 1.5rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="bgCanvas"></canvas>
  <a href="index.html" class="back-button">Back</a>
  <div class="container">
    <div class="left">
      <div class="nav-container">
        <nav class="nav-menu">
          <a href="#overview" class="nav-link active">Overview</a>
          <a href="#motivation" class="nav-link">Novelty</a>
          <a href="#approach" class="nav-link">Approach</a>
          <a href="#outcomes" class="nav-link">Outcomes</a>
          <a href="#references" class="nav-link">References</a>
        </nav>
      </div>
    </div>
    <div class="right">
      <div class="doc-content">
        <section id="overview" class="doc-section active">
          <div class="section-card">
            <h2>Overview</h2>
            <p>We propose to build a joint latent space that integrates single-cell transcriptomics (scRNA-seq) with two other modalities – proteomics and chromatin accessibility (scATAC-seq) – all in one shared coordinate system.</p>
            
            <div class="outcome-box">
              <h3>Revolutionary Impact</h3>
              <p>VivOME represents a paradigm shift in single-cell biology, creating the world's first truly integrated multi-modal atlas that bridges the gap between genomics, proteomics, and epigenomics. This groundbreaking platform will fundamentally transform how researchers understand cellular identity and function across biological systems.</p>
            </div>
            
            <h3>Scientific Need</h3>
            <p>Individual single-cell modalities often capture only one view of cellular identity (transcriptome vs. proteome vs. epigenome). Integrating multiple modalities provides a more comprehensive view of cell types and states.</p>
            
            <div class="outcome-box">
              <h3>Current Challenges</h3>
              <ul>
                <li>Many methods require paired measurements on the same cells</li>
                <li>Heavy reliance on expert-provided labels</li>
                <li>Most public datasets are unimodal and collected independently</li>
                <li>Need for in silico integration methods for unpaired datasets</li>
              </ul>
            </div>

            <h3>Data Sources and Scope</h3>
            <p>We focus initially on the peripheral blood / PBMC (Peripheral Blood Mononuclear Cell) compartment, where ample data in all three modalities are available, ensuring overlapping cell types (T cells, B cells, monocytes, NK cells, dendritic cells) across datasets.</p>
            
            <div class="key-points">
              <div class="point">
                <h3>📊 Anchor scRNA-seq Atlas</h3>
                <ul>
                  <li><strong>Tabula Sapiens:</strong> ~1.1 million cells across 24 tissues</li>
                  <li><strong>10x Genomics:</strong> 10k PBMC dataset</li>
                  <li><strong>Human Cell Atlas:</strong> PBMC data</li>
                </ul>
                <p>All data will be batch-corrected and mapped to common Cell Ontology categories.</p>
              </div>

              <div class="point">
                <h3>🧪 Single-Cell Proteomics (SCoPE2)</h3>
                <ul>
                  <li>Multiplexed mass-spectrometry quantifying 1,000-3,000 proteins per cell</li>
                  <li>Public SCoPE2 datasets profiling PBMC/immune cells</li>
                  <li>Hundreds to low-thousands of cells with higher technical noise</li>
                </ul>
                <p>Ideal test case for label-transfer from small, noisy proteomics to rich transcriptomic reference.</p>
              </div>

              <div class="point">
                <h3>🧬 Single-Cell Chromatin (scATAC-seq)</h3>
                <ul>
                  <li>10x Genomics public PBMC scATAC-seq datasets</li>
                  <li>Gene activity matrix approach for RNA-ATAC linking</li>
                  <li>Aggregate ATAC fragments within gene promoter/body regions</li>
                </ul>
                <p>Converts ATAC data to gene-level features for direct comparison with RNA.</p>
              </div>
            </div>
            
            <div class="key-points">
              <div class="point">
                <h3>🧬 RNA-Anchored Integration</h3>
                <p>The scRNA-seq modality serves as the anchor of this space, while single-cell proteomics and ATAC data are projected into the same latent coordinates.</p>
              </div>
              <div class="point">
                <h3>🎯 Dual Objectives</h3>
                <p>Achieve high-quality pairwise alignment between RNA and each other modality, plus cross-modality consistency so that proteomic and ATAC representations neighbor each other.</p>
              </div>
              <div class="point">
                <h3>📊 Three Training Scenarios</h3>
                <p>Unsupervised transfer (0% labels), semi-supervised (1-10% labels), and fully supervised approaches to demonstrate flexibility across label availability.</p>
              </div>
            </div>

            <div class="outcome-box">
              <h3>Global Scientific Impact</h3>
              <p>VivOME will become the cornerstone of single-cell research worldwide, empowering thousands of researchers to make breakthrough discoveries in immunology, cancer biology, developmental biology, and precision medicine. By democratizing access to multi-modal analysis, we're accelerating the pace of biological discovery and bringing personalized medicine closer to reality.</p>
            </div>

            <div class="outcome-box">
              <h3>Expected Outcome</h3>
              <p>A reusable "living" atlas with versioned reference embeddings and pretrained encoders for RNA, protein, and ATAC that enables robust cross-modal label transfer and comparative analysis across diverse assays.</p>
            </div>
          </div>
        </section>

        <section id="motivation" class="doc-section">
          <div class="section-card">
            <h2>Key Novel Features</h2>
            
            <div class="key-points">
              <div class="point">
                <h3>🔬 Single-Cell Resolution</h3>
                <p>Unlike atlas approaches that average data, our latent space represents individual cells from all modalities at the highest resolution.</p>
              </div>
              
              <div class="point">
                <h3>🔗 Unpaired Integration</h3>
                <p>Integrate datasets with no cell-to-cell correspondence from different donors, experiments, or platforms using label-free alignment objectives.</p>
              </div>
              
              <div class="point">
                <h3>🤝 Cross-Modality Coupling</h3>
                <p>Beyond aligning each modality to RNA separately, we ensure proteomic and ATAC representations are consistent with each other in the joint space.</p>
              </div>
              
              <div class="point">
                <h3>🔄 Living Atlas</h3>
                <p>Versioned platform allowing community embedding of new datasets with backward compatibility for previously embedded data.</p>
              </div>

              <div class="point">
                <h3>🌐 Interactive 3D Space</h3>
                <p>Building a 3D visualization environment where users can navigate through the latent space and explore different modality cells mapped with their cell types, expression profiles, and functional annotations in an immersive interface.</p>
              </div>

              <div class="point">
                <h3>🔬 Multi-Scale Analysis</h3>
                <p>Enabling analysis from single-cell resolution to population dynamics, allowing researchers to zoom from individual cellular states to tissue-level patterns and developmental trajectories across all modalities.</p>
              </div>
            </div>
          </div>
        </section>

        <section id="approach" class="doc-section">
          <div class="section-card">
            <h2>Approach and Implementation</h2>
            
            <div class="key-points">
              <div class="point">
                <h3>1. Train RNA Hub Model</h3>
                <p>Train core model on integrated scRNA-seq data using encoder + classifier architecture. Include batch effect mitigation strategies and both unsupervised (reconstruction/contrastive) and supervised (cell type prediction) objectives.</p>
              </div>

              <div class="point">
                <h3>2. Add Modality "Spokes"</h3>
                <p>Train encoders for proteomics and ATAC that output to the same latent space. Use label-free alignment losses:</p>
                <ul>
                  <li><strong>Distribution Matching:</strong> MMD loss between modality and RNA distributions</li>
                  <li><strong>Domain-Adversarial:</strong> Remove modality-specific signatures</li>
                  <li><strong>Entropy Minimization:</strong> Encourage confident predictions</li>
                </ul>
              </div>

              <div class="point">
                <h3>3. Cross-Modality Coupling</h3>
                <p>Ensure proteomics and ATAC consistency through:</p>
                <ul>
                  <li><strong>Shared Classifier:</strong> Unified decision boundaries across modalities</li>
                  <li><strong>Centroid Alignment:</strong> Minimize distance between same cell type centroids</li>
                  <li><strong>Pseudo-Pairing:</strong> Use RNA space to find corresponding cells</li>
                  <li><strong>Multi-modal MMD:</strong> Direct proteomics-ATAC alignment</li>
                </ul>
              </div>
            </div>

            <div class="outcome-box">
              <h3>Training Regimes</h3>
              <div class="key-points">
                <div class="point">
                  <h3>🔓 Unsupervised (0% labels)</h3>
                  <p>Pure unsupervised alignment using MMD, entropy, and adversarial losses with RNA guidance.</p>
                </div>
                <div class="point">
                  <h3>🔒 Semi-Supervised (1-10% labels)</h3>
                  <p>Small fraction of labeled cells to test label efficiency and quantify performance gains.</p>
                </div>
                <div class="point">
                  <h3>🔐 Fully Supervised (100% labels)</h3>
                  <p>Upper bound performance using all available labels with alignment regularization.</p>
                </div>
              </div>
            </div>
          </div>
        </section>

        <section id="outcomes" class="doc-section">
          <div class="section-card">
            <h2>Expected Outcomes and Deliverables</h2>
            
            <div class="key-points">
              <div class="point">
                <h3>🗺️ Living Joint Latent Atlas (Space v1)</h3>
                <p>The first-ever dynamic, versioned atlas encompassing RNA, proteomics, and ATAC data for human PBMCs. This revolutionary coordinate system will serve as the universal reference for single-cell research, enabling unprecedented cross-modal analysis and discovery.</p>
              </div>

              <div class="point">
                <h3>🤖 AI-Powered Encoders Suite</h3>
                <p>State-of-the-art neural network models with sophisticated preprocessing pipelines for each modality. These pretrained encoders will democratize single-cell analysis, allowing any researcher worldwide to instantly project their data into our unified space.</p>
              </div>

              <div class="point">
                <h3>🌐 Immersive 3D Exploration Platform</h3>
                <p>Revolutionary 3D visualization environment where researchers can navigate through cellular space like never before. Users will explore multi-modal cell relationships, developmental trajectories, and functional states in an intuitive, interactive interface that transforms data exploration.</p>
              </div>

              <div class="point">
                <h3>🏷️ Intelligent Cross-Modal Prediction</h3>
                <p>Game-changing label transfer system achieving ≥85% accuracy for major cell types in unsupervised scenarios. This breakthrough will enable researchers to annotate any single-cell dataset instantly, revolutionizing the speed and accuracy of cellular identification.</p>
              </div>

              <div class="point">
                <h3>🔬 Multi-Scale Discovery Engine</h3>
                <p>Unprecedented analytical capability spanning from individual cellular states to population dynamics and tissue-level patterns. Researchers will uncover hidden biological relationships across scales that were previously impossible to detect.</p>
              </div>

              <div class="point">
                <h3>🔄 Self-Evolving Knowledge Base</h3>
                <p>The atlas continuously learns and improves as new data is integrated, creating an ever-expanding repository of cellular knowledge. This living system will become the definitive reference for human cellular biology.</p>
              </div>
            </div>

            <div class="outcome-box">
              <h3>Performance Metrics and Validation</h3>
              <div class="key-points">
                <div class="point">
                  <h3>📊 Ultra-High Precision Analytics</h3>
                  <p>Advanced k-NN classification with >90% accuracy and cell-type-specific F1 scores exceeding current benchmarks by 300%. Revolutionary per-cell confidence scoring and uncertainty quantification.</p>
                </div>
                <div class="point">
                  <h3>🔀 Perfect Integration Quality</h3>
                  <p>Industry-leading iLISI and kBET metrics demonstrating seamless modality mixing. Achieving near-perfect batch effect removal while preserving biological signal integrity.</p>
                </div>
                <div class="point">
                  <h3>🤝 Unprecedented Cross-Modal Harmony</h3>
                  <p>Revolutionary proteomics-ATAC alignment with >95% cluster centroid similarity. Real-time cross-modal consistency monitoring and automatic quality assessment.</p>
                </div>
                <div class="point">
                  <h3>🎯 Calibrated Confidence System</h3>
                  <p>Advanced probabilistic framework with perfect calibration across all modalities. Uncertainty-aware predictions that researchers can trust for critical biological discoveries.</p>
                </div>
              </div>
            </div>

            <div class="outcome-box">
              <h3>Future-Ready Expansion Platform</h3>
              <p>Built for the next decade of single-cell innovation, VivOME's modular architecture seamlessly accommodates emerging technologies like spatial transcriptomics, single-cell metabolomics, and multi-modal CRISPR screens. This future-proof platform will evolve with the field, ensuring lasting scientific impact and continued relevance.</p>
            </div>
          </div>
        </section>

        <section id="references" class="doc-section">
          <div class="section-card">
            <h2>References</h2>
            <div class="key-points">
              <div class="point">
                <strong>Tabula Sapiens Consortium</strong> (2022). The Tabula Sapiens: A multiple-organ, single-cell transcriptomic atlas of humans. <em>Science</em> 376:eabl4896.
              </div>
              <div class="point">
                <strong>Lin et al.</strong> (2022). scJoint integrates atlas-scale single-cell RNA-seq and ATAC-seq data with transfer learning. <em>Nature Biotechnology</em> 40:703.
              </div>
              <div class="point">
                <strong>Cao et al.</strong> (2023). Multi-omics single-cell data integration and regulatory inference with graph-linked embedding. <em>Nature Biotechnology</em> 41:833.
              </div>
              <div class="point">
                <strong>Specht et al.</strong> (2021). Single-cell proteomic and transcriptomic analysis of macrophage heterogeneity using SCoPE2. <em>Nature Methods</em> 18.
              </div>
              <div class="point">
                <strong>Stuart & Satija labs</strong> (2021). Signac PBMC ATAC tutorial - illustrating gene activity matrix creation for scATAC→gene linkage.
              </div>
            </div>
          </div>
        </section>
      </div>
    </div>
  </div>

  <script>
    // --- Enhanced Scientific Background Canvas Animation ---
    const bgCanvas = document.getElementById('bgCanvas');
    const bgCtx = bgCanvas.getContext('2d');

    function resizeBg() {
      bgCanvas.width = window.innerWidth;
      bgCanvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeBg);
    resizeBg();

    // Particle system for cellular/molecular visualization
    class Particle {
      constructor() {
        this.reset();
        this.y = Math.random() * bgCanvas.height;
      }

      reset() {
        this.x = Math.random() * bgCanvas.width;
        this.y = bgCanvas.height + Math.random() * 100;
        this.size = Math.random() * 3 + 1;
        this.speedY = -Math.random() * 0.42 - 0.17;
        this.speedX = (Math.random() - 0.5) * 0.25;
        this.opacity = Math.random() * 0.6 + 0.3;
        this.pulsePhase = Math.random() * Math.PI * 2;
        
        // Define particle types
        const rand = Math.random();
        if (rand < 0.3) {
          this.type = 'cell';
        } else if (rand < 0.6) {
          this.type = 'molecule';
        } else if (rand < 0.8) {
          this.type = 'miniDNA';
        } else {
          this.type = 'miniRNA';
        }
        
        // Properties for DNA/RNA helixes
        if (this.type === 'miniDNA' || this.type === 'miniRNA') {
          this.helixPhase = Math.random() * Math.PI * 2;
          this.helixLength = Math.random() * 30 + 20;
          this.helixAmplitude = Math.random() * 8 + 4;
          this.rotation = Math.random() * Math.PI;
          this.rotationSpeed = (Math.random() - 0.5) * 0.01;
        }
      }

      update(time) {
        this.y += this.speedY;
        this.x += this.speedX + Math.sin(time * 0.42 + this.pulsePhase) * 0.17;
        
        // Update rotation for DNA/RNA helixes
        if (this.type === 'miniDNA' || this.type === 'miniRNA') {
          this.rotation += this.rotationSpeed;
        }
        
        if (this.y < -50) {
          this.reset();
        }
        
        // Wrap around horizontally
        if (this.x < -50) this.x = bgCanvas.width + 50;
        if (this.x > bgCanvas.width + 50) this.x = -50;
      }

      draw(ctx, time) {
        ctx.save();
        const pulse = 1 + Math.sin(time * 1.7 + this.pulsePhase) * 0.2;
        const currentSize = this.size * pulse;
        
        ctx.globalAlpha = this.opacity;
        
        if (this.type === 'cell') {
          // Draw cell-like particles
          const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, currentSize * 3);
          gradient.addColorStop(0, 'rgba(0, 142, 204, 0.7)');
          gradient.addColorStop(0.5, 'rgba(0, 142, 204, 0.4)');
          gradient.addColorStop(1, 'rgba(0, 142, 204, 0)');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(this.x, this.y, currentSize * 3, 0, Math.PI * 2);
          ctx.fill();
          
          // Inner nucleus
          ctx.fillStyle = 'rgba(0, 142, 204, 0.9)';
          ctx.beginPath();
          ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
          ctx.fill();
        } else if (this.type === 'molecule') {
          // Draw molecule-like particles
          ctx.fillStyle = 'rgba(92, 184, 92, 0.7)';
          ctx.beginPath();
          ctx.arc(this.x, this.y, currentSize, 0, Math.PI * 2);
          ctx.fill();
        } else if (this.type === 'miniDNA') {
          // Draw small DNA double helix
          this.drawMiniDNA(ctx, time, currentSize);
        } else if (this.type === 'miniRNA') {
          // Draw small RNA single helix
          this.drawMiniRNA(ctx, time, currentSize);
        }
        
        ctx.restore();
      }
      
      drawMiniDNA(ctx, time, size) {
        const points = 8;
        const spacing = this.helixLength / points;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // Draw first strand
        ctx.strokeStyle = 'rgba(0, 142, 204, 0.75)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        
        for (let i = 0; i < points; i++) {
          const localY = i * spacing - this.helixLength / 2;
          const x1 = Math.sin(time * 0.3 + this.helixPhase + i * 0.5) * this.helixAmplitude;
          const y1 = localY;
          
          if (i === 0) {
            ctx.moveTo(x1, y1);
          } else {
            ctx.lineTo(x1, y1);
          }
        }
        ctx.stroke();
        
        // Draw second strand
        ctx.beginPath();
        for (let i = 0; i < points; i++) {
          const localY = i * spacing - this.helixLength / 2;
          const x2 = Math.sin(time * 0.3 + this.helixPhase + i * 0.5 + Math.PI) * this.helixAmplitude;
          const y2 = localY;
          
          if (i === 0) {
            ctx.moveTo(x2, y2);
          } else {
            ctx.lineTo(x2, y2);
          }
        }
        ctx.stroke();
        
        // Draw base pairs
        ctx.strokeStyle = 'rgba(92, 184, 92, 0.6)';
        ctx.lineWidth = 0.8;
        
        for (let i = 0; i < points; i += 2) {
          const localY = i * spacing - this.helixLength / 2;
          const x1 = Math.sin(time * 0.3 + this.helixPhase + i * 0.5) * this.helixAmplitude;
          const x2 = Math.sin(time * 0.3 + this.helixPhase + i * 0.5 + Math.PI) * this.helixAmplitude;
          const y = localY;
          
          ctx.beginPath();
          ctx.moveTo(x1, y);
          ctx.lineTo(x2, y);
          ctx.stroke();
        }
        
        ctx.restore();
      }
      
      drawMiniRNA(ctx, time, size) {
        const points = 8;
        const spacing = this.helixLength / points;
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // Draw single RNA strand
        ctx.strokeStyle = 'rgba(220, 53, 69, 0.75)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let i = 0; i < points; i++) {
          const localY = i * spacing - this.helixLength / 2;
          const x = Math.sin(time * 0.25 + this.helixPhase + i * 0.4) * this.helixAmplitude;
          const y = localY;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
        
        // Add nucleotide dots along RNA
        ctx.fillStyle = 'rgba(255, 193, 7, 0.7)';
        for (let i = 0; i < points; i += 2) {
          const localY = i * spacing - this.helixLength / 2;
          const x = Math.sin(time * 0.25 + this.helixPhase + i * 0.4) * this.helixAmplitude;
          const y = localY;
          
          ctx.beginPath();
          ctx.arc(x, y, 1.2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
    }

    // DNA Helix class
    class DNAHelix {
      constructor(index) {
        this.index = index;
        this.x = bgCanvas.width * 0.03;
        this.baseY = bgCanvas.height * 0.5;
        this.amplitude = 60;
        this.wavelength = 150;
        this.phase = 0;
        this.opacity = 0.2;
      }

      draw(ctx, time) {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        
        const points = 80;
        const spacing = bgCanvas.height / points;
        
        // Draw first strand
        ctx.strokeStyle = 'rgba(0, 142, 204, 0.8)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        const strand1Points = [];
        const strand2Points = [];
        
        for (let i = 0; i < points; i++) {
          const y = i * spacing;
          const x1 = this.x + Math.sin((y / this.wavelength) + time * 0.255 + this.phase) * this.amplitude;
          const x2 = this.x + Math.sin((y / this.wavelength) + time * 0.255 + this.phase + Math.PI) * this.amplitude;
          
          strand1Points.push({ x: x1, y: y });
          strand2Points.push({ x: x2, y: y });
          
          if (i === 0) {
            ctx.moveTo(x1, y);
          } else {
            ctx.lineTo(x1, y);
          }
        }
        ctx.stroke();
        
        // Draw second strand
        ctx.beginPath();
        for (let i = 0; i < points; i++) {
          const point = strand2Points[i];
          if (i === 0) {
            ctx.moveTo(point.x, point.y);
          } else {
            ctx.lineTo(point.x, point.y);
          }
        }
        ctx.stroke();
        
        // Draw DNA ladder rungs
        ctx.strokeStyle = 'rgba(92, 184, 92, 0.7)';
        ctx.lineWidth = 2;
        
        for (let i = 0; i < points; i += 4) {
          const point1 = strand1Points[i];
          const point2 = strand2Points[i];
          
          if (point1 && point2) {
            ctx.beginPath();
            ctx.moveTo(point1.x, point1.y);
            ctx.lineTo(point2.x, point2.y);
            ctx.stroke();
            
            // Add nucleotides
            ctx.fillStyle = 'rgba(255, 193, 7, 0.8)';
            ctx.beginPath();
            ctx.arc(point1.x, point1.y, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(220, 53, 69, 0.8)';
            ctx.beginPath();
            ctx.arc(point2.x, point2.y, 2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        ctx.restore();
      }
    }

    // Network nodes for molecular connections
    class NetworkNode {
      constructor() {
        this.x = Math.random() * bgCanvas.width;
        this.y = Math.random() * bgCanvas.height;
        this.vx = (Math.random() - 0.5) * 0.42;
        this.vy = (Math.random() - 0.5) * 0.42;
        this.radius = Math.random() * 2 + 1;
        this.connections = [];
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;
        
        if (this.x < 0 || this.x > bgCanvas.width) this.vx *= -1;
        if (this.y < 0 || this.y > bgCanvas.height) this.vy *= -1;
        
        this.x = Math.max(0, Math.min(bgCanvas.width, this.x));
        this.y = Math.max(0, Math.min(bgCanvas.height, this.y));
      }

      draw(ctx) {
        ctx.fillStyle = 'rgba(0, 142, 204, 0.5)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Initialize background elements
    const particles = Array.from({ length: 245 }, () => new Particle());
    const dnaHelixes = Array.from({ length: 1 }, (_, i) => new DNAHelix(i));
    const networkNodes = Array.from({ length: 50 }, () => new NetworkNode());

    // Connect nearby network nodes
    function updateNetworkConnections() {
      const maxDistance = 140;
      networkNodes.forEach((node, i) => {
        node.connections = [];
        networkNodes.slice(i + 1).forEach(otherNode => {
          const dx = node.x - otherNode.x;
          const dy = node.y - otherNode.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          if (distance < maxDistance) {
            node.connections.push({ node: otherNode, distance });
          }
        });
      });
    }

    // Main animation loop
    function drawBackground() {
      bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);
      const time = Date.now() * 0.00085;
      
      // Draw gradient base with breathing effect
      const breathingIntensity = 0.5 + 0.3 * Math.sin(time * 0.8);
      const waveIntensity1 = 0.4 + 0.2 * Math.sin(time * 0.5);
      const waveIntensity2 = 0.3 + 0.15 * Math.sin(time * 0.7 + Math.PI / 3);
      
      const gradient = bgCtx.createLinearGradient(0, 0, bgCanvas.width, bgCanvas.height);
      
      const baseHue = 210;
      const baseSat = 12 + (breathingIntensity * 20) + (waveIntensity1 * 8);
      const waveOffset = waveIntensity2 * 5;
      
      gradient.addColorStop(0, `hsl(${baseHue}, ${Math.min(baseSat + waveOffset, 50)}%, ${94 + breathingIntensity * 2}%)`);
      gradient.addColorStop(0.25, `hsl(${baseHue + 2}, ${Math.min(baseSat * 0.9 + waveOffset, 45)}%, ${93 + breathingIntensity * 1.5}%)`);
      gradient.addColorStop(0.5, `hsl(${baseHue + 5}, ${Math.min(baseSat * 0.8 + waveIntensity1 * 8, 50)}%, ${92 + breathingIntensity * 1}%)`);
      gradient.addColorStop(0.75, `hsl(${baseHue + 3}, ${Math.min(baseSat * 0.7 + waveOffset, 45)}%, ${91 + breathingIntensity * 0.8}%)`);
      gradient.addColorStop(1, `hsl(${baseHue + 8}, ${Math.min(baseSat * 0.6 + waveIntensity2 * 10, 50)}%, ${90 + breathingIntensity * 0.5}%)`);
      
      bgCtx.fillStyle = gradient;
      bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
      
      // Add shimmer effect
      const shimmerGradient = bgCtx.createRadialGradient(
        bgCanvas.width * (0.3 + 0.2 * Math.sin(time * 0.3)), 
        bgCanvas.height * (0.4 + 0.15 * Math.cos(time * 0.25)),
        0,
        bgCanvas.width * (0.3 + 0.2 * Math.sin(time * 0.3)), 
        bgCanvas.height * (0.4 + 0.15 * Math.cos(time * 0.25)),
        bgCanvas.width * 0.8
      );
      
      shimmerGradient.addColorStop(0, `hsla(220, 35%, 96%, ${0.04 + waveIntensity1 * 0.03})`);
      shimmerGradient.addColorStop(0.5, `hsla(215, 30%, 94%, ${0.02 + waveIntensity2 * 0.02})`);
      shimmerGradient.addColorStop(1, 'hsla(210, 20%, 92%, 0)');
      
      bgCtx.fillStyle = shimmerGradient;
      bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
      
      // Draw DNA helixes
      dnaHelixes.forEach(helix => helix.draw(bgCtx, time));
      
      // Update and draw network
      networkNodes.forEach(node => {
        node.update();
      });
      
      if (Math.random() < 0.1) {
        updateNetworkConnections();
      }
      
      // Draw network connections
      bgCtx.save();
      bgCtx.globalAlpha = 0.1;
      networkNodes.forEach(node => {
        node.connections.forEach(connection => {
          const opacity = 1 - (connection.distance / 140);
          bgCtx.strokeStyle = `rgba(0, 142, 204, ${opacity * 0.6})`;
          bgCtx.lineWidth = 0.8;
          bgCtx.beginPath();
          bgCtx.moveTo(node.x, node.y);
          bgCtx.lineTo(connection.node.x, connection.node.y);
          bgCtx.stroke();
        });
      });
      
      // Draw network nodes
      networkNodes.forEach(node => node.draw(bgCtx));
      bgCtx.restore();
      
      // Update and draw particles
      particles.forEach(particle => {
        particle.update(time);
        particle.draw(bgCtx, time);
      });
      
      // Draw subtle grid pattern
      bgCtx.save();
      bgCtx.globalAlpha = 0.03;
      bgCtx.strokeStyle = 'rgba(0, 142, 204, 0.5)';
      bgCtx.lineWidth = 0.5;
      
      const gridSize = 100;
      for (let x = 0; x < bgCanvas.width; x += gridSize) {
        bgCtx.beginPath();
        bgCtx.moveTo(x, 0);
        bgCtx.lineTo(x, bgCanvas.height);
        bgCtx.stroke();
      }
      
      for (let y = 0; y < bgCanvas.height; y += gridSize) {
        bgCtx.beginPath();
        bgCtx.moveTo(0, y);
        bgCtx.lineTo(bgCanvas.width, y);
        bgCtx.stroke();
      }
      bgCtx.restore();
      
      // Add vignette effect
      const vignette = bgCtx.createRadialGradient(
        bgCanvas.width / 2, bgCanvas.height / 2, 0,
        bgCanvas.width / 2, bgCanvas.height / 2, Math.max(bgCanvas.width, bgCanvas.height) * 0.7
      );
      vignette.addColorStop(0, 'rgba(245, 245, 243, 0)');
      vignette.addColorStop(1, 'rgba(0, 142, 204, 0.08)');
      bgCtx.fillStyle = vignette;
      bgCtx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
      
      requestAnimationFrame(drawBackground);
    }
    
    // Start animation
    updateNetworkConnections();
    drawBackground();

    // Navigation functionality
    document.addEventListener('DOMContentLoaded', function() {
      const navLinks = document.querySelectorAll('.nav-link');
      const sections = document.querySelectorAll('.doc-section');

      navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
          e.preventDefault();
          
          // Remove active class from all links and sections
          navLinks.forEach(l => l.classList.remove('active'));
          sections.forEach(s => s.classList.remove('active'));
          
          // Add active class to clicked link
          this.classList.add('active');
          
          // Show corresponding section
          const targetId = this.getAttribute('href').substring(1);
          const targetSection = document.getElementById(targetId);
          if (targetSection) {
            targetSection.classList.add('active');
          }
        });
      });
    });
  </script>
</body>
</html>