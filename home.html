<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vivome – A Living Joint Latent Atlas for Single-Cell Omics</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;800&display=swap"
      rel="stylesheet"
    />
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html {
        scroll-behavior: smooth;
      }
      body {
        margin: 0;
        font-family: "Montserrat", sans-serif;
        scroll-snap-type: y mandatory;
        overflow-x: hidden;
        background: #000;
        color: #fff;
      }
      section {
        min-height: 100vh;
        scroll-snap-align: start;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        padding: 0 1rem;
      }

      /* Home section */
      #home {
        color: #fff;
      }
      #home h1 {
        font-size: 7rem;
        margin: 0 0 1rem 0;
        font-weight: 800;
        background: linear-gradient(135deg, #00d2ff, #3a7bd5);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow:
          0 0 6px rgba(0, 210, 255, 0.4),
          0 0 12px rgba(0, 210, 255, 0.2);
        animation: halo 6s ease-in-out infinite;
      }
      @keyframes halo {
        0%,
        100% {
          text-shadow:
            0 0 6px rgba(0, 210, 255, 0.4),
            0 0 12px rgba(0, 210, 255, 0.2);
        }
        50% {
          text-shadow:
            0 0 15px rgba(0, 210, 255, 0.7),
            0 0 25px rgba(0, 210, 255, 0.5);
        }
      }
      #home p {
        font-size: 2rem;
        max-width: 700px;
        margin: 0 auto;
      }

      /* Removed button styles */

      /* Documentation section */
      #documentation {
        color: #fff;
      }
      #documentation .content {
        max-width: 900px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        padding: 2rem;
      }
      #documentation h2 {
        color: #00d2ff;
        margin-top: 0;
      }
      #documentation section {
        margin-bottom: 2rem;
        min-height: 0;
        scroll-snap-align: unset;
      }


      /* Background canvas */
      #protein-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        background: #000;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <canvas id="protein-canvas"></canvas>

    <section id="home">
      <h1>Vivome</h1>
      <p>A Living Joint Latent Atlas for Single-Cell Omics</p>
    </section>

    <section id="documentation">
      <div class="content">
        <section>
          <h2>Overview</h2>
          <p>
            Vivome is an open, evolving platform designed to integrate three
            major single-cell data modalities – transcriptomics (scRNA-seq),
            proteomics, and chromatin accessibility (scATAC-seq) – into a
            single, unified coordinate system. By anchoring everything to a rich
            RNA reference, Vivome allows seamless projection of unpaired
            datasets, enabling researchers to explore cellular identity from
            multiple biological angles without requiring matched multi-omic
            experiments.
          </p>
        </section>
        <section>
          <h2>Why It Matters</h2>
          <p>
            Each single-cell modality captures only part of a cell’s story. RNA
            tells us what genes are expressed, proteomics reveals the proteins
            actually present, and ATAC-seq shows how the genome is accessible.
            Vivome bridges these views, aligning them so that researchers can
            uncover patterns, validate discoveries, and transfer cell type
            labels across datasets with minimal or even zero prior annotation.
          </p>
        </section>
        <section>
          <h2>What Makes Vivome Unique</h2>
          <ul>
            <li>
              <strong>Fully Single-Cell Resolution:</strong> Every point
              represents a real single cell across RNA, protein, or chromatin
              data.
            </li>
            <li>
              <strong>Unpaired Data Integration:</strong> Aligns datasets
              without requiring the same cells to be measured across modalities.
            </li>
            <li>
              <strong>Cross-Modality Coupling:</strong> Ensures proteomic and
              ATAC data are aligned to each other, not just to RNA.
            </li>
            <li>
              <strong>Open and Versioned:</strong> Provides pretrained encoders
              and reference embeddings so the atlas grows with new data.
            </li>
          </ul>
        </section>
        <section>
          <h2>Intended Impact</h2>
          <p>
            Vivome will enable scientists worldwide to project their own
            single-cell datasets into a shared atlas, instantly contextualizing
            them with rich multi-omic reference data. By removing barriers to
            cross-modality analysis, this platform will accelerate biological
            discoveries in immunology, systems biology, and beyond.
          </p>
        </section>
        <section>
          <p><a href="visuals.html" style="color: #00d2ff;">View Visuals</a></p>
        </section>
      </div>
    </section>
    <script>
      const canvas = document.getElementById("protein-canvas");
      const ctx = canvas.getContext("2d");
      const colors = ["#ff6b6b", "#f0a500", "#4ecdc4", "#3a7bd5", "#b388eb"];
      let particles = [];
      let cw, ch, dpr;

      function resize() {
        dpr = window.devicePixelRatio || 1;
        cw = window.innerWidth;
        ch = window.innerHeight;
        canvas.width = cw * dpr;
        canvas.height = ch * dpr;
        canvas.style.width = cw + "px";
        canvas.style.height = ch + "px";
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        initParticles();
      }
      window.addEventListener("resize", resize);
      resize();

      function initParticles() {
        particles = [];
        const count = Math.floor((cw + ch) / 50);
        for (let i = 0; i < count; i++) {
          particles.push({
            x: Math.random() * cw,
            y: Math.random() * ch,
            vx: (Math.random() - 0.5) * 0.3,
            vy: (Math.random() - 0.5) * 0.3,
            r: 8 + Math.random() * 4,
            color: colors[Math.floor(Math.random() * colors.length)],
            phase: Math.random() * Math.PI * 2,
          });
        }
      }

      function draw() {
        ctx.clearRect(0, 0, cw, ch);
        const time = performance.now() * 0.002;
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          p.x += p.vx;
          p.y += p.vy;
          if (p.x < 0 || p.x > cw) p.vx *= -1;
          if (p.y < 0 || p.y > ch) p.vy *= -1;

          const grad = ctx.createRadialGradient(
            p.x - p.r / 3,
            p.y - p.r / 3,
            p.r / 5,
            p.x,
            p.y,
            p.r
          );
          grad.addColorStop(0, "#fff");
          grad.addColorStop(1, p.color);
          ctx.shadowColor = p.color;
          ctx.shadowBlur = 20 + 10 * Math.sin(time + p.phase);
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fillStyle = grad;
          ctx.fill();
          ctx.shadowBlur = 0;

          for (let j = i + 1; j < particles.length; j++) {
            const q = particles[j];
            const dx = p.x - q.x;
            const dy = p.y - q.y;
            const dist = Math.hypot(dx, dy);
            if (dist < 120) {
              ctx.strokeStyle = "#fff";
              ctx.globalAlpha = 0.3;
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(p.x, p.y);
              ctx.lineTo(q.x, q.y);
              ctx.stroke();
              ctx.globalAlpha = 1;
            }
          }
        }
        requestAnimationFrame(draw);
      }
      draw();
    </script>
  </body>
</html>
