<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VivOME â€“ A Living Joint Latent Atlas for Single-Cell Omics</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <style>
    *, *::before, *::after { box-sizing: border-box; }
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: "Poppins", sans-serif;
      display: flex;
      height: 100vh;
    }
    .left {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: flex-start;
      padding-left: 5vw;
    }
    .left h1 {
      font-size: 9rem;
      margin: 0 0 1rem 0;
      font-weight: 700;
      background: linear-gradient(135deg, #00d2ff, #3a7bd5);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .left p {
      font-size: 1.5rem;
      margin: 0;
    }
    .right {
      flex: 1;
      position: relative;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <div class="left">
    <h1>VivOME</h1>
    <p>A Living Joint Latent Atlas for Single-Cell Omics</p>
  </div>
  <div class="right">
    <canvas id="scene"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('scene');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    const scene = new THREE.Scene();

    function resize() {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    }

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.z = 5;

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(3, 3, 5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));

    const spheres = [];
    const glowTexture = new THREE.TextureLoader().load(
      'https://threejs.org/examples/textures/sprites/glow.png'
    );
    const sphereInfo = [
      { pos: new THREE.Vector3(-0.5, 1, 0), color: 0xff6b6b, url: 'documentation.html' },
      { pos: new THREE.Vector3(0.5, 0, 0), color: 0xf0a500, url: 'visual.html' },
      { pos: new THREE.Vector3(-0.5, -1, 0), color: 0x4ecdc4, url: 'code.html' },
    ];

    const group = new THREE.Group();
    sphereInfo.forEach(info => {
      const geom = new THREE.SphereGeometry(0.2, 32, 32);
      const mat = new THREE.MeshStandardMaterial({
        color: info.color,
        emissive: info.color,
        emissiveIntensity: 1,
      });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.copy(info.pos);
      const glow = new THREE.Sprite(
        new THREE.SpriteMaterial({
          map: glowTexture,
          color: info.color,
          transparent: true,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
        })
      );
      glow.scale.set(0.8, 0.8, 1);
      mesh.add(glow);
      mesh.add(new THREE.PointLight(info.color, 1, 2));
      mesh.userData.url = info.url;
      spheres.push(mesh);
      group.add(mesh);
    });

    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
    for (let i = 0; i < sphereInfo.length - 1; i++) {
      const points = [sphereInfo[i].pos, sphereInfo[i + 1].pos];
      const geo = new THREE.BufferGeometry().setFromPoints(points);
      group.add(new THREE.Line(geo, lineMaterial));
    }

    group.scale.set(0.8, 0.8, 0.8);
    scene.add(group);

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    function onClick(event) {
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(spheres);
      if (intersects.length > 0) {
        window.location.href = intersects[0].object.userData.url;
      }
    }
    canvas.addEventListener('click', onClick);
    window.addEventListener('resize', resize);
    resize();

    function animate() {
      requestAnimationFrame(animate);
      group.rotation.y += 0.01;
      const time = Date.now() * 0.002;
      spheres.forEach((s, i) => {
        const scale = 1 + 0.1 * Math.sin(time + i);
        s.scale.set(scale, scale, scale);
      });
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
